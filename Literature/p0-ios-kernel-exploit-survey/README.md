# iOS 内核利用公开案例速览（iOS 10–13）——读 Project Zero Survey 的笔记

> 原文：A survey of recent iOS kernel exploits（Brandon Azad, Project Zero, 2020-06-11）
> 
> https://projectzero.google/2020/06/a-survey-of-recent-ios-kernel-exploits.html

这篇笔记是对 Project Zero 的 survey 做“中文结构化复述 + 模式归纳”。目标不是逐条翻译细节，而是把从漏洞到 kernel read/write（以及常见的 tfp0/伪造内核 task port）的高层流程，按可复用的套路总结出来，方便后续读具体 exploit 代码/文章时快速对齐。

快速入口：

- [索引（事件 + 安全机制）](index.md)
- [事件笔记目录](events/)
- [安全机制笔记目录](mitigations/)

---

## 1. 这份 survey 在解决什么问题

Survey 试图把 iOS 10–13 期间、从“本地 App 上下文（local app context）”出发的公开 iOS 内核利用，统一用同一种语言描述：

- 漏洞本身给了什么 **exploit primitive（利用原语）**
- 如何用漏洞特性把环境“推到一个稳定、可重复”的原语（作者称 **exploit strategy**）
- 之后如何用一串相对通用的 **exploit techniques（利用技术）**，把原语一步步升级到最终目标（作者称 **exploit flow**）

这种写法的好处是：你不需要先记住每个 CVE 的微观细节，也能看出“最近几年 iOS kernel exploit 的常见流水线”。

---

## 2. 术语速记：primitive / strategy / technique / flow

作者对术语做了约定（不同研究者可能用词不同，这里按原文的语境理解）：

- **Exploit primitive（利用原语）**：一次利用过程中获得的、相对通用的能力。例如：受控的线性越界写、任意读写、受控 PC、对某地址的引用计数操作等。
- **Exploit strategy（利用策略）**：针对具体漏洞的“前半段工程”，目标是把漏洞变成一个稳定、可复用的原语。
- **Exploit technique（利用技术）**：可复用的方法论，用来把一个原语转换成另一个更强的原语。例如 ROP、利用 fake Mach port 建读原语等。
- **Exploit flow（利用流程）**：把上述 techniques 串起来的高层链路，从初始原语一路到目标（此 survey 的目标多为 kernel read/write）。

这套定义对于读 iOS/XNU 利用特别有用，因为很多 exploit 表面看起来五花八门，但“中后段”经常高度相似。

---

## 3. 高层共性：从漏洞到 kernel read/write 的“常见流水线”

把 survey 中多个 exploit 横向对齐后，会频繁看到如下模式（并非每个都包含所有步骤）：

### 3.1 先把堆布局“做出来”（heap grooming / spray）

iOS 内核利用的可靠性很大部分来自工程化的堆操控：

- **spray（喷射）**：诱导内核分配大量可控对象（常见载体：IOSurface properties / OOL memory / OOL ports / pipe buffers 等）。
- **hole / reclaim（挖洞与回收）**：制造可预测的空洞，再让目标类型重新占位。

直觉上：漏洞只是“能打到某个对象”，而 spray/groom 是“让你能打到你想要的对象”。

### 3.2 信息泄露与破 KASLR：vtable、内核指针、或扫描

KASLR 需要被绕过几乎是必选项。survey 里出现的思路包括：

- 读出某个对象的 **vtable 指针**（进而推导 kernel slide）
- 直接泄露内核指针（例如未初始化内存 copyout）
- 通过某个“能返回内核指针”的接口/副作用，或通过读原语从某已知指针向后扫描定位 kernel text base

不同 exploit 的差异在于：信息泄露发生得早还是晚、以及泄露的是哪类指针（text / heap / object）。

### 3.3 核心主线：Mach port / fake port 作为“把手”

大量 iOS kernel exploit 会在某个阶段得到或构造：

- **dangling Mach port（悬挂 port）**：进程仍持有某个 right，但内核对象已被释放/复用
- **fake Mach port（伪造 port）**：在可控缓冲中伪造 `ipc_port`（或相关结构），使内核把它当作 port 用

为什么 port 这么关键？因为 Mach port 是很多系统调用/内核路径的入口。把它变成“可控对象”，就能把很多 kernel API 变成“读/写/调用”的工具。

### 3.4 读原语常见落点：fake task port + `pid_for_task()` 等

survey 多次出现“把 fake port 变成 fake task port，再通过 `pid_for_task()` 建立任意读”的思路（具体实现因版本与缓解不同而异）。

从抽象层看：

- 先获得“能影响某个内核对象字段”的能力（UAF / OOB write / overwrite descriptor）
- 再让某条内核路径基于被篡改的对象执行“对攻击者有意义的动作”（例如读出某地址、或对某地址进行 copyin/copyout）

### 3.5 再到写：copyin/copyout、任意函数调用、或结构体拼装

写原语的来源在 survey 里大概分几类：

- **copyin/copyout 变体**：把参数/函数指针/目标地址变得可控
- **受限但足够的任意函数调用**：例如通过特定 gadget 构造 2/3/7 参数调用
- **通过已建立的读写能力直接修补关键数据结构**（例如当前 task 的 special ports、或构造 fake kernel task port）

到这里就会进入大家熟悉的“做出稳定的 kernel r/w，接着实现更高层目标”的阶段。

---

## 4. 读 survey 时值得特别关注的“常见材料/载体”

Survey 中反复出现的“可控数据落点”和“搬运机制”大致有：

- **OOL ports / OOL memory（Mach 消息中的 out-of-line 描述符）**：常用于喷射、制造重叠、或让 userspace 收到/持有特定 rights。
- **IOSurface properties / OSData / OSString**：典型的“可控内核分配载体”，既能喷射也能读回。
- **pipe buffers**：常用于占位、持久化可控内存、或作为可映射/可读写的缓冲。
- **IOKit user client / vtable hijack / method dispatch**：一些 exploit 会尝试劫持虚表调用，但这类技术在后期会受到 PAC 等缓解影响。

这几个关键词几乎是 iOS 10–13 时代本地内核利用的高频“积木”。

---

## 5. 缓解机制（mitigations）如何影响利用路径

Survey 末尾把缓解机制和利用技术做了映射。按学习价值（对利用链影响大小）粗略排序：

### 5.1 KASLR / heap randomization：几乎每条链都要处理

- KASLR 让你不能硬编码内核地址
- heap randomization 让“把对象喷到固定地址”变得困难

对应的工程化对策：信息泄露 + spray/groom。

### 5.2 PAN：内核不能随便读写 userspace 指针

PAN 让“把结构体放在用户态内存，诱导内核去用”变得不直接。

对应对策：把可控数据**喷进内核**，并通过泄露/定位拿到内核侧地址；或利用共享映射等机制。

### 5.3 KTRR / W^X / PXN：把“改代码页/执行注入”路线堵死

现代公开 iOS kernel exploit 基本不会走“改页表写 shellcode”，而是更多通过：

- 篡改内核数据结构
- 代码复用（gadget/调用现有函数）

### 5.4 PAC：强约束“指针篡改 → 控制流”

PAC 在 A12 及以后显著收紧了 vtable 劫持、函数指针篡改等路径的可用性。

直觉上：

- 早期很多链路会把“得到代码执行”作为中间跳板，再转成读写
- PAC 让这条路变得不再“默认可行”，迫使 exploit 更依赖数据结构层面的读写/逻辑链

### 5.5 zone_require（iOS 13）：打击 fake Mach port

当内核频繁检查“这个指针是否来自预期 zone”（例如 Mach port 必须来自 `ipc.ports` 区），那种把 `ipc_port` 伪造在 `OSData/kalloc` 里的路线会被直接识别并中断。

它并不让 exploitation 消失，但会改变“fake port”的落点与构造方式，或迫使攻击者寻找绕过。

---

## 6. 如何用这份 survey 组织你自己的学习

建议把学习目标拆成两层：

- **层 1：看懂“共性流水线”**：spray/groom → 泄露/定位 → fake/dangling port → 读 → 写 → 伪造 kernel task port
- **层 2：补齐“每个积木的实现细节”**：Mach 消息、OOL 描述符、IOSurface property 内存模型、pipe buffer 行为、XNU zone/kalloc、task/port 数据结构等

下一步你可以从 survey 中挑 2–3 个典型条目做“深入读原文/代码”，例如：

- `mach_portal` / `extra_recipe`：早期 Mach/消息与 OOL 相关套路
- `async_wake`：典型“信息泄露 + dangling port → fake port → 读”路径
- `voucher_swap` / `machswap2`：iOS 12 时代围绕 voucher/MIG 语义的链路
- `SockPuppet`：以“可靠原语堆叠”为中心的层次化结构
- `oob_timestamp`：iOS 13 与 zone_require 时代的变化

更具体的学习路线我整理在同目录的学习大纲里。
