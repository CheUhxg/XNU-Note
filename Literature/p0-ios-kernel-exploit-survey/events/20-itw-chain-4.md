# In-the-wild iOS Exploit Chain 4 (cfprefsd + ProvInfoIOKit)

- 目标系统: iOS 12.1.3
- CVE: CVE-2019-7287

## 初始原语（primitive）
ProvInfoIOKitUserClient::ucEncryptSUInfo() 线性堆溢出（未检查 memcpy）。

## 漏洞特定利用策略（strategy）
第一次触发把目标 port 地址拷入可读 OSData；第二次触发把 port 指针插入 OOL ports array；free port + GC 留下 dangling 指针；pipe buffers 重占位并接收 OOL ports 得到 fake port right。

## 后续通用利用流程（subsequent exploit flow）
fake clock port + clock_sleep_trap brute force；fake task port + pid_for_task 读；构造 fake kernel task port。

## 关键可复用技术点（techniques）
- 用拷贝溢出做指针搬运到 OSData
- OOL ports 搬运 rights
- clock brute force + pid_for_task

## 与缓解机制的关系（notes）
- in-the-wild 复盘。

## 参考
- [writeup](https://projectzero.google/2019/08/in-wild-ios-exploit-chain-4.html)
- [Apple security content](https://support.apple.com/lt-lt/HT209520)

### 参考内容摘要

**原文概述**：Chain 4 解析，目标 iOS 12.1.3。引入新架构：沙盒逃逸与内核 exploit 独立化。沙盒逃逸针对 cfprefsd（核心偏好设置守护进程）的 XPC 服务：处理 CFPreferences 操作时，对 sub-messages 先 retain 再迭代，但 iteration 过程中若 sub-message 为字典且包含特定 operation key 则直接 destroy 所有 sub-messages（over-release），导致外层持有的 request message 也被误释放。攻击者利用四线程并发发送特殊构造消息（CFPreferencesOperation=5 + 10000 个 xpc_data spray），在 free 窗口期用 xpc_data 替换已释放的 xpc_dictionary 结构，控制后续字段（如嵌套字典、数组指针）实现任意内存读写，最终执行 ROP chain（绕过 longjmp PAC 保护）打开并返回 ProvInfoIOKitUserClient 句柄。内核漏洞在 ProvInfoIOKitUserClient::ucEncryptSUInfo：第一条 memmove 直接使用用户传入的长度字段而未校验，造成完全可控堆溢出。利用策略复杂度升级：第一次触发溢出从 kalloc.4096 OOL memory 读出 target_port 地址并写入 OSData（用 IOSurface 读回泄露）；第二次触发把读到的两个 port 指针写入 kalloc.6144 OOL ports 数组（变相插入 port references 而无需真实 retain）；free target 和周边 ports、force GC、reallocate with pipe buffers；接收包含 OOL ports 的消息即可获得指向 pipe buffer 的 port right（即 fake port）；fake selector cache 技术绕过 Objective-C 消息派发的 PAC 检查；后续利用与前几条链相同。标记设备方式改为将 kern.maxfilesperproc sysctl 设为 0x27ff。攻击者为何从 Chain 3 迁移到 Chain 4？因为 Chain 4 更可靠、只用单个漏洞且避免了基于线程的 reallocation 技术的隐患，代价是沙盒逃逸部分需要处理更多复杂的 XPC/ROP 细节。
