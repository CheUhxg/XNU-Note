# voucher_swap

- 目标系统: iOS 12.1.2
- CVE: CVE-2019-6225

## 初始原语（primitive）
同 CVE-2019-6225：dangling voucher。

## 漏洞特定利用策略（strategy）
groom ipc_port 与 pipe buffers；触发漏洞/GC 形成 ith_voucher dangling。

## 后续通用利用流程（subsequent exploit flow）
OOL ports array 重占位并把 ipc_port 指针“推进”到 pipe buffers 形成 fake port；notification 泄露另一个 port 地址计算 fake port 自身地址；pid_for_task 建读；构造 fake kernel task port。

## 关键可复用技术点（techniques）
- 指针搬运到 pipe buffer
- notification 泄露
- pid_for_task 读

## 与缓解机制的关系（notes）
- 建议配合原作者 writeup 理解 MIG 语义。

## 参考
- [writeup](https://projectzero.google/2019/01/voucherswap-exploiting-mig-reference.html)
- [exploit code](https://bugs.chromium.org/p/project-zero/issues/detail?id=1731#c10)

### 参考内容摘要

**原文概述**：Brandon Azad 对 CVE-2019-6225 的发现和利用详解（同 Chain 5 的漏洞）。从调查 semaphore_destroy 引用计数溢出时观察到 MIG wrapper 代码的非传统语义：_Xsemaphore_destroy 无论成功失败都消费 semaphore 引用。由此推导出 MIG inout 对象的扩展语义规则：①入参不持有引用（borrowed）；②inout 输入值持有引用且应被消费；③失败时输出值不持有引用；④成功时输出值持有引用并捐赠给 wrapper 由后者消费。而 task_swap_mach_voucher 实现直接将 new_voucher 赋值给 *in_out_old_voucher，违反上述规则导致泄漏旧引用 + 消费借用引用的双重错误。Voucher 是 reference-counted、immutable 的属性集合（iv_refs 在 iOS 12 使用 os_refcnt_t 限制范围 1-0x0fffffff），主要被 libdispatch 使用。利用思路：通过 thread_set/get_mach_voucher 使线程 ith_voucher 持有 dangling voucher 引用；用 OOL ports 数组重分配 voucher 结构，使 iv_refs 字段与 base port 的低 32 位重叠（需设备刚启动后执行以确保指针低 32 位在合法范围）；调用 thread_get_mach_voucher 在 iv_port=NULL 时会分配新 port 并写入该字段；通过多次 leak/modify iv_refs 将 base port 指针"推进"至后续 pipe buffers；最终获得完全可控的 fake port（通过 pipe fd 读写内存）；使用 mach_port_request_notification 在 fake port 的 ip_pdrequest 字段写入另一已知 port 指针，读回后可定位 fake task 结构地址；fake task 置于 mach message 中（通过 send 到 fake port），读 ip_messages.imq_messages 获取 ipc_kmsg 地址从而确定 fake task 位置；利用 pid_for_task 建立 4 字节任意读（每次泄漏一个 ipc_kmsg）；接着用 mach_port_get_attributes(MACH_PORT_DNREQUESTS_SIZE) 建立更好的读原语（fake port ip_context 与 fake ip_requests its_size 重叠，通过 set_context 更新读地址）；分配 kernel memory 并构造最终的 fake kernel task；cleanup 泄漏的 ipc_kmsg。技术亮点：①OOL ports 重叠 voucher 并"推进"指针；②pipe buffers 承载完全可控 fake port；③利用 notification、message queue 等机制进行地址泄露与定位；④exploit 可靠性在刚启动后接近 99%，可完全 cleanup 留下稳定系统。该 bug 提醒：MIG 语义极不直观且缺乏公开文档，只能通过仔细阅读 auto-generated 代码来正确使用；placeholder 代码也需严格审查；os_refcnt_t 虽未完全阻止，但至少影响了 exploit 可靠性（仅在干净启动后可靠）。
