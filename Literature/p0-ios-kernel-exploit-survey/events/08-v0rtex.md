# v0rtex

- 目标系统: iOS 10.3.3
- CVE: CVE-2017-13861

## 初始原语（primitive）
dangling Mach port（引用错误）。

## 漏洞特定利用策略（strategy）
spray ports 并触发 bug drop ref；释放同页其他 ports 得到 dangling receive right。

## 后续通用利用流程（subsequent exploit flow）
zone GC + IOSurface OSString 重分配；通过 notification 字段塞入指针并用 IOSurface 读回泄露；mach_port_get_attributes 做 4-byte 读原语（可用 context 更新地址）；进一步构造 fake task port 与 iokit_user_client_trap 7 参数任意调用，最终 fake kernel task port。

## 关键可复用技术点（techniques）
- IOSurface/OSString 重分配
- notification 泄露指针
- mach_port_get_attributes 读原语变体
- iokit_user_client_trap 任意调用

## 与缓解机制的关系（notes）
- 建议对照 writeup/代码画对象关系图。

## 参考
- [writeup](https://siguza.github.io/v0rtex/)
- [code](https://github.com/Siguza/v0rtex)

### 参考内容摘要

**原文概述**：Siguza 对 windknown 在 Pangu 博客披露的 IOSurface Mach port UAF（iOS 11.2 修复、Ian Beer 报告）的独立 exploit 实现（配合 Ian 的 async_wake）。Bug 在用户提供 port 的首次和后续注册时引用计数减少不一致，导致可获得仍有效的 userland handle 但 port 已被释放。利用策略分多阶段：①分配 realport；②喷射 0x1000 before ports；③分配 target port（后称 fakeport）；④喷射 0x100 after ports，形成 target 被同组 ports 包围的 zone chunk；⑤触发 bug 增加 port 引用计数但引入异步性（sleep 1s 后同步）；⑥用 mach_ports_register 注册 target port 和 IOSurfaceRootUserClient；⑦usleep(100ms) 同步；⑧再次 mach_ports_register 减少引用触发同步释放；⑨释放 before/after ports 并 mach_zone_force_gc（iOS 11 已禁用但可通过在每个 zone 分配/释放大量内存并测量耗时来触发）；⑩用 OSUnserializeXML（通过 IOSurface external methods 9/10/11）以 OSString（0xfff 字节得到 0x1000 分配）替换 freed page；⑪构造能在三种 page offset（0x0/0x68/0x28，因 ipc.ports zone 分配 0x3000 导致跨页）下都有效的 triple port 结构（关键是 lock 完整）；⑫用 mach_port_get_context 读取 ip_context 字段判断 offset 并识别 OSString 编号（高 32 位编码 offset 标记和 OSString id）；⑬重新分配正确 offset 的干净 port；⑭用 mach_port_request_notification 在 fake port 的 ip_pdrequest 字段写入 realport 指针，读回 OSString 泄露；⑮从 realport 遍历：receiver(ipc_space) → is_task(task_t) → itk_registered[0](IOSurfaceRootUserClient port) → ip_kobject(object) → vtab，得到 kernel slide；⑯用 mach_port_get_attributes(MACH_PORT_DNREQUESTS_SIZE) 变体建立任意 4 字节读（fake port ip_context 与 fake ip_requests its_size 重叠，用 set_context 更新读地址，避免 A10 SMAP 和 userland shared address space 问题）；⑰泄露 fake port 地址（通过再次 request_notification）；⑱构造 fake IOUserClient + vtable（getExternalTrapForIndex 指向 gadget：add x0,x0,10; ret），在 vtable 后放置 fake object 和函数指针；⑲用 mach_vm_remap 将 OSString buffer 映射到用户空间（使用 zone_map port 而非 kernel_map），实现完全 kernel r/w + 任意函数调用（通过 iokit_user_client_trap，可控 6 参数 + target + func，返回值传回用户但截断到 32 位）；⑳构造两个 fake task（kernel_map/zone_map）传给 mach_vm_remap；㉑调用 ipc_port_alloc_special 返回低 32 位（结合 zone_map base 恢复完整指针）；㉒用 ipc_kobject_set + ipc_port_make_send 构造 fake kernel task port（vm_map_remap 复制 kernel_task 到新地址绕过指针检查）；㉓调用 bzero 清空 self_task ucred uid 提权；㉔复制 kernel p_ucred->cr_label 到自己实现脱沙盒。技术亮点：①三重 offset 兼容的 port 结构设计；②利用 IOSurface/OSString、notification、mach_port_get_attributes、mach_vm_remap、iokit_user_client_trap 等多种机制组合；③通过遍历内核对象图获取关键指针。未来工作：32 位适配需重新分析 page offset；等待作者编写 patchfinder。
