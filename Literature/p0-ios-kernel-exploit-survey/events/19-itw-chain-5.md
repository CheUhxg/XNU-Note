# In-the-wild iOS Exploit Chain 5 (task_swap_mach_voucher)

- 目标系统: iOS 12.1.2
- CVE: CVE-2019-6225

## 初始原语（primitive）
同 CVE-2019-6225：dangling voucher。

## 漏洞特定利用策略（strategy）
喷射 vouchers 并触发漏洞/GC 形成 ith_voucher dangling。

## 后续通用利用流程（subsequent exploit flow）
OOL memory spray 泄露 voucher port 地址；再次 spray 更新 iv_port；destroy ports + GC 让 fake voucher 指向 dangling port；pipe buffers 重占位；thread_get_mach_voucher 得到 fake port right；pid_for_task 建读；构造 fake kernel task port。

## 关键可复用技术点（techniques）
- OOL memory/ports 作为喷射与回收
- GC + destroy 制造 dangling
- pipe 重占位

## 与缓解机制的关系（notes）
- in-the-wild 复盘。

## 参考
- [writeup](https://projectzero.google/2019/08/in-wild-ios-exploit-chain-5.html)

### 参考内容摘要

**原文概述**：Chain 5 深度分析（iOS 11.4.1-12.1.2），这是与 Project Zero Brandon Azad 和 360 @S0rryMybad 的三方碰撞案例（Brandon 于 2018/12/6 报告，Apple 2019/1/22 在 iOS 12.1.4 修复并同时致谢二人；@S0rryMybad 在 2018/11/17 用此漏洞赢得天府杯 $200k）。漏洞位于 task_swap_mach_voucher MIG 方法：该函数为 2014 年新增的 voucher 功能的未完成实现（placeholder），从未正常工作过——任何尝试以预期参数调用都会导致 panic，四年间从未被执行过一次（无论开发、测试、QA 或生产）。根因是 MIG 的 inout 语义极难正确使用：auto-generated wrapper 代码会在函数前调用 convert_port_to_voucher 添加引用、函数后调用 destructor ipc_voucher_release 消费引用，但实现函数自身将 new_voucher（借用引用）直接赋值给 *in_out_old_voucher（原本持有引用）而未 release 旧值，造成泄漏一个引用 + 消费一个不属于自己的引用的双重引用计数错误。攻击者利用该漏洞可完全控制 voucher 的 iv_refs 字段。利用策略：分配 0x2000 个 unique vouchers（使用 ATM voucher 确保每次都是新对象）作为 before 组、target voucher、0x1000 个 after 组；通过 sleeper thread 持有 target voucher 引用；触发漏洞使 voucher 实际引用数少于应有值；销毁 before/target/after ports 使 target voucher 被释放但 thread 的 ith_voucher 仍指向它；force GC；发送 80MB OOL memory（内含 fake voucher，iv_refs=0x100、iv_port=NULL）；分配 discloser_before/neighbour/discloser_after ports 包围；调用 thread_get_mach_voucher 在 fake voucher 的 iv_port 字段写入新分配的 port 地址（写到 OOL memory buffer）；接收 OOL memory 读回该地址；重新发送 OOL memory 但将 iv_port 指针抬高 16k 指向下一 zone chunk（全是 discloser_after ports）；销毁 discloser ports + GC；用 pipe buffers 替换该 zone chunk；再次 thread_get_mach_voucher 获得指向 pipe buffer 的 voucher port；通过 pid_for_task 确定 replacer pipe fd；使用 kread32 搜索 neighbour port（ip_context=0x1337733100）定位 ipc_space → task → proc；遍历 allproc 找到自己和 launchd；临时获取 launchd ucred、patch platform policy、inject trust cache CDHash、spawn implant、标记设备（kern.maxfilesperprof=0x27ff）。该链的存在说明：攻击者已拥有当时有效的 Chain 4，却仍迁移到全新的 Chain 5，原因是后者更可靠（单个漏洞，避免线程 reallocation）。更重要的启示：placeholder 代码也可引入严重安全漏洞，应与功能代码同等审查；os_refcnt_t 虽未阻止此漏洞被利用，但至少限制了引用计数范围，影响了 exploit 可靠性（需重启后执行）。
