# extra_recipe

- 目标系统: iOS 10.2
- CVE: CVE-2017-2370

## 初始原语（primitive）
mach_voucher_extract_attr_recipe_trap() 中 copyin 长度可控导致线性堆溢出。

## 漏洞特定利用策略（strategy）
溢出破坏 ipc_kmsg.ikm_size，形成可重复的 240 字节 OOB 读写（通过异常消息覆盖/读取）。

## 后续通用利用流程（subsequent exploit flow）
读取对象泄露地址、读 vtable 破 KASLR；覆写 vtable 让虚调用落到 OSSerializer::serialize gadget，得到受限任意调用；再用 uuid_copy 建立任意读写。

## 关键可复用技术点（techniques）
- exception message 驱动覆盖/读取
- vtable 泄露破 KASLR
- OSSerializer::serialize gadget → 任意调用 → r/w

## 与缓解机制的关系（notes）
- 属于“利用 ipc_kmsg 扩容/重叠”典型链路。

## 参考
- [Exception oriented exploitation on iOS](https://projectzero.google/2017/04/exception-oriented-exploitation-on-ios.html)
- [exploit code](https://bugs.chromium.org/p/project-zero/issues/detail?id=1004#c4)

### 参考内容摘要

**原文概述**：Ian Beer 对 CVE-2017-2370 的发现与利用详解（extra_recipe，iOS 10.2）。漏洞在新增的 mach_voucher_extract_attr_recipe_trap：该 trap 接受 recipe_size 指针参数，需先 copyin 4 字节获取大小；小于 MACH_VOUCHER_TRAP_STACK_LIMIT(256) 时用 VLA 在栈上处理，否则 kalloc(sz) 并 copyin(recipe, krecipe, recipe_size)。问题在于第三个参数：应为 sz（copyin 得到的值），却误写为 args->recipe_size（指针值），导致可控大规模溢出（copyin 限制 <0x4000000）。推测根因：从 host_create_mach_voucher_trap copypasta 时，原函数 size 为整数、新函数为指针，开发者添加 copyin 但忘记更新第三个参数；clang 报错提示"recipes_size → recipe_size?"（少一个 s），开发者采纳建议却引入语义错误。Primitive 构建：通过 pagezero_size=0 映射低地址，让 recipe_size 既是合法指针又是溢出长度；数据对齐到页尾，unmap 下一页使 copyin 在到达边界时 fault 停止，精确控制溢出长度（256-5120 字节）。目标对象：ipc_kmsg（preallocated port 分配，包含 header + body）。策略：①分配大量 ipc_kmsg 填充 zone；②分配 holder/first/second prealloc ports（连续）；③释放 holder；④触发溢出（reallocate holder 并覆盖到 first port 的 ipc_kmsg，修改 ikm_size 为 0x1104）；⑤重新获取 holder；⑥向 first port 发送 valid header message（入队到 first port 的 message queue，ikm_next/prev 指向自己）；⑦向 second port 发送 message（写入自身 ipc_kmsg 地址到 buffer）；⑧从 first port 接收消息，因 ikm_size 被改大，读到 second port 的 message 内容，泄露 second port ipc_kmsg 地址。关键技术：send_prealloc_msg 用 load_regs_and_crash asm stub 将 buffer 内容加载到 x0-x29，触发 software breakpoint，exception_deliver 调用 mach_exception_raise_state 序列化寄存器到 exception message 并发送到 target port（利用修改过的 ikm_size 使 message body 对齐到错误位置，覆盖相邻 ipc_kmsg）。知道 ipc_kmsg 地址后可反复读写固定 240 字节区域。地址泄露：已有旧 kernel exploit（mach_portal），利用其 kernel r/w 实现"kernel debugger with printf"（allocate ipc_kmsg、get_port 返回 kernel 地址、试错确定正确 ikm_size 覆盖值）。Get-where-what 原语：重复上述覆盖/读回技巧，泄露 second port ipc_kmsg 地址。最终利用：①释放 second port；②用 AGXCommandQueue userclient 替换（alloc_userclient type 5）；③读回 vtable 指针计算 kernel slide；④构造 fake userclient，重定向 vtable 到自身，插入 OSSerializer::serialize 地址（调用 ::release 变为调用 serialize(fake_obj, dict)）；⑤serialize 内部从 dict 取两个参数，调用 fake_obj->func(arg1, arg2)；⑥使用 uuid_copy（wrapper of memmove，固定 size=16）作为 func，实现 16 字节任意读写（读：uuid_copy(fake_obj, arbitrary_addr)；写：uuid_copy(arbitrary_addr, fake_obj)，配合 receive exception message 读回）；⑦最终构造 fake kernel task port。该 bug 本应被单元测试/code review/fuzzing 快速发现（>256 字节 recipe 直接 panic），且 MacOS 上任何测试都会立即 panic。作者强调：关键代码缺乏基本回归测试是持续问题（XNU 和其他代码库共同的痛点），LG Android 内核甚至有 unbounded strcpy 的自定义 syscall 与 sys_seccomp 冲突导致 Chrome 触发。
