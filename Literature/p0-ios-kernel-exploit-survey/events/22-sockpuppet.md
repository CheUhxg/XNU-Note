# SockPuppet

- 目标系统: iOS 12.2 / 12.4
- CVE: CVE-2019-8605

## 初始原语（primitive）
in6_pcbdetach() UAF，可构造安全的任意读、任意 kfree、端口地址泄露原语。

## 漏洞特定利用策略（strategy）
用 OSData/IOSurface 重占位 ip6_pktopts，实现：getsockopt 读、setsockopt free、OOL ports 泄露 port 指针。

## 后续通用利用流程（subsequent exploit flow）
泄露当前 task；找到 pipe buffers；在 pipe buffer 构造 fake kernel task port；释放另一 pipe buffer 并用 OOL ports array 重占位；写 pipe 插入 fake port 指针并接收得到 fake kernel task port。

## 关键可复用技术点（techniques）
- 可验证重占位的稳定原语
- getsockopt/setsockopt 触发器
- pipe buffer 作为承载

## 与缓解机制的关系（notes）
- survey 注记：结构更像分层而非线性；12.3 修复后 12.4 回归。

## 参考
- [walkthrough](https://projectzero.google/2019/12/sockpuppet-walkthrough-of-kernel.html)
- [exploit code](https://bugs.chromium.org/p/project-zero/issues/detail?id=1806#c13)

### 参考内容摘要

**原文概述**：Google Project Zero Ned Williamson 对 CVE-2019-8605 的深度剖析（配合 LiveOverflow 视频）。漏洞为 IPv6 套接字选项处理中的 UAF，iOS 12.2 引入、12.3 修复、12.4 回归后 8 月再次修复。作者使用 LibFuzzer + protobuf-mutator 对 XNU 网络栈进行 fuzzing：定义 protobuf 描述系统调用（socket/bind/connect/setsockopt/getsockopt/shutdown 等）及其参数枚举，将 protobuf 消息序列转为实际系统调用执行；通过反复优化 grammar（如将 setsockopt name 参数限制为 enum 而非任意 int32）并监控覆盖率来引导 fuzzer 发现 bug。原始 PoC 仅影响 raw sockets（需 root），通过限定到非特权 socket options 并继续 fuzz，最终发现针对 IPV6_2292PKTINFO 的完全可利用 PoC。Bug 在 in6_pcbdetach 中：disconnect 套接字会调用 in6p_outputopts->ip6po_pktinfo 的 FREE，但未清空指针；后续 getsockopt/setsockopt 仍可访问该已释放指针。Primitive 极强：①通过 getsockopt 任意读（IPV6_2292PKTINFO 读 in6po_pktinfo 指向内容）；②通过 setsockopt(IPV6_PKTINFO, all-zero-20-bytes) 任意 kfree（调用 ip6_clearpktopts → FREE(in6po_pktinfo)）；③通过 OOL ports spray 泄露 port 指针（与 in6po_pktinfo 字段重叠）。由于原语非常强，跳过传统弱原语构建阶段。利用策略：IOSurface spray OSData 重分配 ip6_pktopts（用 minmtu 魔术值验证成功）；使用 freed ip6_pktopts 的 in6po_pktinfo 指针读内核数据；通过 OOL ports 泄露 base port 指针并推导 pipe buffer 地址；在 pipe buffer 构建完整 fake kernel task（包括 fake task、map 等）；用另一套 socket UAF 释放 ip6_pktopts 并用 OOL ports 数组替换（base port 指向 pipe 中 fake task）；接收 OOL ports 消息获得指向 fake kernel task 的 port right；使用 mach_vm_read/write 验证 kernel r/w。由于所有对象都在同一 generic size-based zone（无需 zone GC），exploit 速度极快且可靠。PAC/MTE 分析：需伪造/替换的指针包括 ipc_space_kernel、kernel_map、fake_port、fake_task 以及中间遍历所需指针；由于已有强读原语，多数已签名指针可直接复制而无需伪造；主要问题在于需伪造 file descriptor table 中的指针来实现超过 20 字节的读取；iOS 13 仅部分保护 data pointers（如 IPC port 指针在 beta 中未保护，但 BlackHat 演讲表明计划保护）；MTE 对本 bug 影响有限，因 UAF read primitive + controlled reallocation 足以绕过 tag checking（除非使用 per-allocation unique tags）。Meta 技术点：IOSurface/OSData spray、OOL ports/memory descriptors、pipe buffers、host port 遍历寻找 kernel_task port、fake kernel task port 复制、zone GC（本 exploit 未用）等均为常见手法。作者通过 fuzzer 在持续集成中自动测试发现了 95 个 Chromium QUIC 相关回归；建议 Apple 更频繁公开 XNU 源码，允许社区对每次 commit 进行 fuzzing 以在 beta 前捕获回归（如 iOS 12.4 的回归本可避免）。
