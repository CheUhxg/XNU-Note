from __future__ import annotations

from pathlib import Path

ROOT = Path(__file__).resolve().parent


def ev(
    *,
    title: str,
    ios: str,
    cves: str | None,
    primitive: str,
    strategy: str,
    flow: str,
    techniques: list[str],
    notes: list[str],
    refs: list[tuple[str, str]],
) -> str:
    cve_line = f"- CVE: {cves}\n" if cves else "- CVE: （survey 条目未给出或为多漏洞）\n"
    tech = "\n".join([f"- {t}" for t in techniques]) if techniques else "- （略）"
    n = "\n".join([f"- {x}" for x in notes]) if notes else "- （略）"
    r = "\n".join([f"- [{name}]({url})" for name, url in refs]) if refs else "- Survey 原文条目"
    return (
        f"# {title}\n\n"
        f"- 目标系统: {ios}\n"
        f"{cve_line}\n"
        f"## 初始原语（primitive）\n{primitive}\n\n"
        f"## 漏洞特定利用策略（strategy）\n{strategy}\n\n"
        f"## 后续通用利用流程（subsequent exploit flow）\n{flow}\n\n"
        f"## 关键可复用技术点（techniques）\n{tech}\n\n"
        f"## 与缓解机制的关系（notes）\n{n}\n\n"
        f"## 参考\n{r}\n"
    )


def main() -> None:
    files: dict[Path, str] = {}

    # -----------------
    # Mitigations pages
    # -----------------
    files[ROOT / "mitigations/kernel-stack-canaries.md"] = """# Kernel Stack Canaries（iOS 6）

## 机制是什么
内核栈 canary（stack cookie）用于检测**栈缓冲区溢出**导致的返回地址/栈帧篡改，典型做法是在栈上放置随机值并在函数返回前校验。

## 对利用链的影响（按 survey 的结论）
- survey 指出：其列举的 iOS 10–13 公开内核利用大多不是“栈溢出”，因此**基本不受该机制直接影响**。

## 学习要点
- 能区分：栈溢出 vs 堆溢出 vs UAF vs 引用计数/MIG 语义类 bug。
- 看到 exploit flow 里主要是 heap grooming / fake objects 时，通常与栈 canary 无关。

## 参考
- Survey：iOS kernel exploit mitigations / Kernel Stack Canaries
"""

    files[ROOT / "mitigations/kernel-aslr.md"] = """# Kernel ASLR（KASLR，iOS 6）

## 机制是什么
KASLR 随机化 kernelcache 映像在内核地址空间的基址，导致内核函数/全局符号地址不再固定。

## 对利用链的影响
- survey 强调：现代 iOS 内核利用几乎都需要**绕过或工作在 KASLR 之下**。
- 常见做法：
  - 信息泄露得到 kernel text 指针或 vtable 指针，从而推导 slide
  - 先拿到内核读原语，再扫描定位 kernel text base（在某些链路里出现）

## 常见“绕过路径”（在 survey 多条目中出现）
- 读取某对象 vtable 指针 → 推导 slide
- 泄露内核指针（例如未初始化内存 copyout）
- brute force 某类指针（在部分链路中与 fake clock port 等组合出现）

## 参考
- Survey：iOS kernel exploit mitigations / Kernel ASLR
"""

    files[ROOT / "mitigations/kernel-heap-aslr.md"] = """# Kernel Heap ASLR（iOS 6）

## 机制是什么
内核堆相关区域基址随机化，降低“把对象稳定放在某个硬编码地址”的可行性。

## 对利用链的影响
- survey 指出：现代利用通常通过 **heap spray / grooming** 来“塑形”，即使不知道精确地址也能影响布局。
- 另一路线是先拿到**信息泄露**，得到关键对象地址后再做精准操作。

## 典型工程化对策
- spray：IOSurface properties / OOL memory / OOL ports / pipe buffers 等载体
- reclaim：制造 hole、触发回收/GC、让目标类型重新占位

## 参考
- Survey：iOS kernel exploit mitigations / Kernel Heap ASLR
"""

    files[ROOT / "mitigations/wx-dep.md"] = """# W^X / DEP（iOS 6）

## 机制是什么
W^X（write xor execute）要求内核页要么可写要么可执行；DEP 强调数据页不可执行，减少注入 shellcode 的传统路线。

## 对利用链的影响
- survey 总结：现代公开 iOS 内核利用通常不尝试改页表注入代码，而是：
  - 篡改内核数据结构
  - 代码复用（调用已有内核代码路径、gadget、间接调用）
- 这也与更强的硬件机制（如 KTRR）共同作用。

## 参考
- Survey：iOS kernel exploit mitigations / W^X / DEP
"""

    files[ROOT / "mitigations/pxn.md"] = """# PXN（iOS 7）

## 机制是什么
PXN（Privileged Execute-Never）用于防止内核在特权态执行 userspace 映射中的代码页（避免“跳到用户态 shellcode”）。

## 对利用链的影响
- 与 W^X 类似，survey 认为现代公开 iOS 内核利用通常不依赖执行 userspace shellcode；PXN 的存在更像是“堵住传统跳板”，而不是主要博弈点。

## 参考
- Survey：iOS kernel exploit mitigations / PXN
"""

    files[ROOT / "mitigations/pan.md"] = """# PAN（iOS 10，对应 A10）

## 机制是什么
PAN（Privileged Access Never）阻止内核直接访问同时对用户态可访问的虚拟地址，避免内核随意解引用攻击者提供的 userspace 指针。

## 对利用链的影响（survey 的归纳）
- 很多“把假结构体放在用户态内存让内核用”的套路在 PAN 下不可直接用。
- 现代 exploit 常见的应对是：
  - 把可控数据喷进内核（IOSurface/pipe/OOL 等），再通过泄露/定位得到内核地址
  - 或利用共享内存映射等机制建立可控的 kernel 可访问区域
- survey 也提到：曾有公开绕过，但大多数利用选择“work around”而非正面绕过。

## 参考
- Survey：iOS kernel exploit mitigations / PAN
"""

    files[ROOT / "mitigations/ktrr-kip.md"] = """# KTRR / KIP v1（iOS 10，对应 A10）

## 机制是什么
KTRR（常被理解为 Kernel Text Readonly Region）是 Apple 在 A10 引入的硬件级保护，覆盖 kernelcache 中只读部分及一些敏感结构（如顶层页表、trust cache 等），强化 W^X，使其更难被软件层面绕过。

## 对利用链的影响（survey 的归纳）
- 现代公开 exploit 往往采取“绕开 KTRR 保护区”的策略：
  - 不去修改 KTRR 保护的内存
  - 更多通过修改非保护区的数据结构达成目标

## 参考
- Survey：iOS kernel exploit mitigations / KTRR
"""

    files[ROOT / "mitigations/aprr.md"] = """# APRR（iOS 11，对应 A11+）

## 机制是什么
APRR（一种自定义硬件特性）将页表权限位间接化：PTE 中的权限位变成索引，真正的权限由寄存器控制，可按核原子切换一组页的权限。

## 对利用链的影响（survey 的归纳）
- APRR 本身不直接提供边界，但为在同一地址空间内部做权限分层创造条件。
- 它被 PPL 大量使用，用于在内核内部建立更强的安全边界。

## 参考
- Survey：iOS kernel exploit mitigations / APRR
"""

    files[ROOT / "mitigations/ppl.md"] = """# PPL（Page Protection Layer，iOS 12）

## 机制是什么
PPL 是建立在 APRR（并依赖 KTRR）的软件层，目标是在“拥有 kernel r/w/x”与“直接控制页表/映射敏感物理地址”之间建立边界。其重点之一是保护已签名用户态代码页，防止攻击者用内核读写去篡改用户态进程的可执行代码。

## 对利用链的影响（survey 的归纳）
- survey 结论（截至 2020-05）：PPL 尚无公开绕过；但当时公开的 iOS 10–13 本地内核利用总体上**还没有被 PPL 显著阻断**。
- 学习上要注意：即使有 kernel r/w，后续能做什么（例如持久化修改 page tables、写入受保护区域）可能被 PPL 限制。

## 参考
- Survey：iOS kernel exploit mitigations / PPL
"""

    files[ROOT / "mitigations/pac.md"] = """# PAC（Pointer Authentication Codes，iOS 12，对应 A12）

## 机制是什么
PAC 是 ARMv8.3-A 的指针认证机制，将指针值的签名放入高位，用于检测指针篡改。Apple 在 A12 引入并强化实现，使其在内核里承担类似 CFI 的效果：把“内核读写”与“稳定的内核代码执行”隔开。

## 对利用链的影响（survey 的归纳）
- PAC 会显著限制依赖控制流劫持的技术（例如 vtable/fptr 篡改直接变成任意执行）。
- survey 指出：过去有些链路会先拿到执行再转读写；在 A12 上通常不再是默认可行路线，除非先绕过 PAC。
- IOKit 中大量 PAC 保护指针的使用，也让“把 bug 变成好用原语”变得更困难。

## 参考
- Survey：iOS kernel exploit mitigations / PAC
"""

    files[ROOT / "mitigations/zone_require.md"] = """# zone_require（iOS 13）

## 机制是什么
zone_require 是 iOS 13 引入的软件缓解：在使用某些关键对象指针前，检查该指针是否来自预期的 zalloc zone。

## 对利用链的影响（survey 的归纳）
- 对 iOS kernel exploit 影响很大的一点是：Mach port 等对象会被频繁检查（例如 lock `ipc_port` 时检查其是否来自 `ipc.ports` zone）。
- 这会直接打击“把 fake Mach port 伪造在 OSData/kalloc 缓冲里”的常见套路。
- survey 提到曾有公开绕过，但依赖实现疏漏，且容易修补。

## 参考
- Survey：iOS kernel exploit mitigations / zone_require
"""

    # --------
    # Events
    # --------
    files[ROOT / "events/01-mach_portal.md"] = ev(
        title="mach_portal",
        ios="iOS 10.1.1",
        cves="CVE-2016-7644",
        primitive="通过竞争条件导致 Mach port 被 over-release，进而制造悬挂 port（dangling ipc_port）。",
        strategy="喷射大量 Mach ports 并在 set_dp_control_port() 上 race；释放后形成一页范围的 dangling ports。",
        flow="触发 zone GC 让页被 OOL ports array 复用；用 mach_port_get_context 泄露 host port 地址并猜测 kernel task port 页；设置 context 为候选 ipc_port 地址并接收 OOL ports，得到 kernel task port send right。",
        techniques=[
            "dangling Mach port 作为把手",
            "zone GC + OOL ports spray 复用内存",
            "mach_port_get_context 作为泄露/探测",
        ],
        notes=[
            "iOS 10 时代可触发 mach_zone_force_gc()，后续版本该条件变化。",
        ],
        refs=[("mach_portal exploit code", "https://bugs.chromium.org/p/project-zero/issues/detail?id=965#c2")],
    )

    files[ROOT / "events/02-itw-chain-1.md"] = ev(
        title="In-the-wild iOS Exploit Chain 1",
        ios="iOS 10.1.1",
        cves=None,
        primitive="AGXAllocationList2::initWithSharedResourceList() 线性堆 OOB 写，覆盖相邻结构指针。",
        strategy="通过布局让溢出覆盖 recv_msg_elem.uio；用 IOSurface 管理的 OSData 伪造 uio 并反复释放/重分配。",
        flow="通过外部方法/OSSerializer::serialize gadget 实现任意 read-then-write，把 kernel task port 地址写入当前 task special ports，再从 userspace 读回得到 port right。",
        techniques=[
            "IOSurface/OSData 作为可控分配载体",
            "OSSerializer::serialize gadget",
            "special ports 通道",
        ],
        notes=["in-the-wild 复盘，细节以引用文章为准。"],
        refs=[("writeup", "https://projectzero.google/2019/08/in-wild-ios-exploit-chain-1.html")],
    )

    files[ROOT / "events/03-extra_recipe.md"] = ev(
        title="extra_recipe",
        ios="iOS 10.2",
        cves="CVE-2017-2370",
        primitive="mach_voucher_extract_attr_recipe_trap() 中 copyin 长度可控导致线性堆溢出。",
        strategy="溢出破坏 ipc_kmsg.ikm_size，形成可重复的 240 字节 OOB 读写（通过异常消息覆盖/读取）。",
        flow="读取对象泄露地址、读 vtable 破 KASLR；覆写 vtable 让虚调用落到 OSSerializer::serialize gadget，得到受限任意调用；再用 uuid_copy 建立任意读写。",
        techniques=[
            "exception message 驱动覆盖/读取",
            "vtable 泄露破 KASLR",
            "OSSerializer::serialize gadget → 任意调用 → r/w",
        ],
        notes=["属于“利用 ipc_kmsg 扩容/重叠”典型链路。"],
        refs=[
            ("Exception oriented exploitation on iOS", "https://projectzero.google/2017/04/exception-oriented-exploitation-on-ios.html"),
            ("exploit code", "https://bugs.chromium.org/p/project-zero/issues/detail?id=1004#c4"),
        ],
    )

    files[ROOT / "events/04-yalu102.md"] = ev(
        title="Yalu102",
        ios="iOS 10.2",
        cves="CVE-2017-2370",
        primitive="溢出覆盖 OOL port array，在 userspace 插入 fake Mach port 指针；接收得到 fake port send right。",
        strategy="直接把 OOL ports array 条目改成指向 userspace 伪造 port。",
        flow="fake port→clock port，用 clock_sleep_trap 暴力猜测内核指针；再转 fake task port 用 pid_for_task 建读原语；扫描定位 kernel text base 破 KASLR；构造 fake kernel task port。",
        techniques=[
            "OOL ports 注入 fake port 指针",
            "clock_sleep_trap brute force",
            "pid_for_task 读原语 + 扫描",
        ],
        notes=["survey 注记：PAN 启用时不可用。"],
        refs=[("exploit code", "https://github.com/kpwn/yalu102")],
    )

    files[ROOT / "events/05-ziva.md"] = ev(
        title="ziVA",
        ios="iOS 10.3.1",
        cves=None,
        primitive="AppleAVE2 多漏洞组合，泄露地址并触发受控虚调用。",
        strategy="泄露 IOSurface 地址与 IOFence vtable 破 KASLR；IOSurface property spray 重分配为可控对象；外部方法信任 userspace 指针导致虚调用劫持。",
        flow="用 OSSerializer::serialize gadget 调用 copyin 覆写 sysctl_oid；组合 sysctl 读得到 3 参数任意调用；用 copyin/copyout 实现任意读写。",
        techniques=[
            "vtable 泄露破 KASLR",
            "gadget 构造任意调用",
            "sysctl 作为触发入口",
        ],
        notes=["iOS 10.3 引入 task_conversion_eval 初形态，之后多需 fake kernel task port。"],
        refs=[
            ("BlackHat slides", "https://www.blackhat.com/docs/eu-17/materials/eu-17-Donenfeld-Rooten-Apples-Vulnerability-Heaven-In-The-IOS-Sandbox.pdf"),
            ("exploit code", "https://github.com/doadam/ziVA"),
        ],
    )

    files[ROOT / "events/06-async_wake.md"] = ev(
        title="async_wake",
        ios="iOS 11.1.2",
        cves="CVE-2017-13861 + CVE-2017-13865",
        primitive="信息泄露定位 port 地址 + 引用错误制造 dangling port。",
        strategy="用泄露找到任意 ports 地址；选择目标 port 触发 bug 释放，得到已知地址 dangling receive right。",
        flow="强制 zone GC，让页被 ipc_kmsg 复用形成可控 fake port；转 fake task port 用 pid_for_task 建读原语（地址可通过 mach_port_set_context 更新）；定位对象并构造 fake kernel task port。",
        techniques=[
            "信息泄露 + 定点 dangling port",
            "pid_for_task 读原语（可更新地址）",
        ],
        notes=["survey 注记：iOS 11 移除 mach_zone_force_gc，后续需新 GC 触发技术。"],
        refs=[("exploit code", "https://bugs.chromium.org/p/project-zero/issues/detail?id=1417#c17")],
    )

    files[ROOT / "events/07-itw-chain-2.md"] = ev(
        title="In-the-wild iOS Exploit Chain 2 (IOSurface)",
        ios="iOS 10.3.3",
        cves="CVE-2017-13861",
        primitive="引用错误制造 dangling ports，并通过重分配与 segmented spray 精确定位落点。",
        strategy="用 mach_port_get_context 泄露另一 port 地址作为锚点；重复触发获得已知地址 dangling port。",
        flow="segmented OOL memory spray 定位段；pipe buffers 重分配得到可控 fake port；clock_sleep_trap brute force 破 KASLR；pid_for_task 建读原语；构造 fake kernel task port。",
        techniques=[
            "context 重叠泄露地址",
            "segmented spray 做落点定位",
            "pipe buffer 承载 fake port",
        ],
        notes=["in-the-wild 复盘，细节以引用文章为准。"],
        refs=[("writeup", "https://projectzero.google/2019/08/in-wild-ios-exploit-chain-2.html")],
    )

    files[ROOT / "events/08-v0rtex.md"] = ev(
        title="v0rtex",
        ios="iOS 10.3.3",
        cves="CVE-2017-13861",
        primitive="dangling Mach port（引用错误）。",
        strategy="spray ports 并触发 bug drop ref；释放同页其他 ports 得到 dangling receive right。",
        flow="zone GC + IOSurface OSString 重分配；通过 notification 字段塞入指针并用 IOSurface 读回泄露；mach_port_get_attributes 做 4-byte 读原语（可用 context 更新地址）；进一步构造 fake task port 与 iokit_user_client_trap 7 参数任意调用，最终 fake kernel task port。",
        techniques=[
            "IOSurface/OSString 重分配",
            "notification 泄露指针",
            "mach_port_get_attributes 读原语变体",
            "iokit_user_client_trap 任意调用",
        ],
        notes=["建议对照 writeup/代码画对象关系图。"],
        refs=[("writeup", "https://siguza.github.io/v0rtex/"), ("code", "https://github.com/Siguza/v0rtex")],
    )

    files[ROOT / "events/09-bpf-filter-poc.md"] = ev(
        title="Incomplete exploit for CVE-2018-4150 (bpf-filter-poc)",
        ios="iOS 11.2.6",
        cves="CVE-2018-4150",
        primitive="BPF race 导致线性堆溢出，覆盖 OOL ports array 并注入 userspace fake port 指针。",
        strategy="触发 race 增长长度但未重分配；发送 packet 溢出到 OOL ports array；接收得到 fake port right。",
        flow="clock_sleep_trap brute force；pid_for_task 建读原语并扫描定位 kernel text base；后续构造 fake kernel task port（条目注记：实现不完整）。",
        techniques=[
            "OOL ports 注入 fake port",
            "clock_sleep_trap brute force",
            "pid_for_task 读 + 扫描",
        ],
        notes=["survey 注记：PAN 启用时不可用；链路不完整。"],
        refs=[
            ("POC", "https://github.com/Jailbreaks/CVE-2018-4150/blob/master/CVE-2018-4150.c"),
            ("repo", "https://github.com/littlelailo/incomplete-exploit-for-CVE-2018-4150-bpf-filter-poc-"),
        ],
    )

    files[ROOT / "events/10-multi_path.md"] = ev(
        title="multi_path",
        ios="iOS 11.3.1",
        cves="CVE-2018-4241",
        primitive="mptcp_usr_connectx bounds check 错误导致 intra-object 线性堆溢出，可污染指针低字节并通过 kfree 制造 UAF。",
        strategy="让 ipc_kmsg 位于特定对齐边界附近；两次触发使同地址被释放/复用，得到 dangling pipe buffer。",
        flow="用 preallocated ipc_kmsg 与异常消息制造重叠，读 pipe 得到地址；改写 ipc_kmsg 使接收得到 pipe buffer 内 fake port 的 send right；转 pid_for_task 读原语；构造 fake kernel task port。",
        techniques=[
            "指针低字节污染 + kfree 形成可控复用",
            "pipe buffer 作为容器",
            "异常消息与 ipc_kmsg 重叠",
        ],
        notes=[],
        refs=[("exploit code", "https://bugs.chromium.org/p/project-zero/issues/detail?id=1558#c3")],
    )

    files[ROOT / "events/11-multipath_kfree.md"] = ev(
        title="multipath_kfree",
        ios="iOS 11.3.1",
        cves="CVE-2018-4241",
        primitive="同 CVE-2018-4241 的另一条链：通过部分释放/重叠最终达到可控虚调用与任意调用原语。",
        strategy="多次触发制造 hole 与部分释放 ipc_kmsg；用 mach_port_peek 定位；喷射填洞读取自指针泄露地址；再次触发释放留下已知地址对象。",
        flow="AGXCommandQueue 重占位，读 vtable 破 KASLR；通过消息重叠更新对象，劫持虚调用到 OSSerializer::serialize gadget，形成 3 参数任意调用（通过异常消息更新参数）。",
        techniques=[
            "mach_port_peek 探测",
            "vtable 泄露破 KASLR",
            "gadget + 重叠更新构造任意调用",
        ],
        notes=["细节密度高，建议对照代码。"],
        refs=[("exploit code", "https://github.com/potmdehex/multipath_kfree")],
    )

    files[ROOT / "events/12-empty_list.md"] = ev(
        title="empty_list",
        ios="iOS 11.3.1",
        cves="CVE-2018-4243",
        primitive="受限写原语：越界写 8 字节 0（off-by-end zeroing）。",
        strategy="复杂 groom 让 kalloc.16 与 ipc.ports 交替并逆转 freelist；反复触发直到清零影响到后续页的 ipc_port 开头字段；再释放得到 dangling port。",
        flow="zone GC + OOL ports array 泄露地址；pipe buffers 重分配得到可控 fake port；pid_for_task 建读原语；构造 fake kernel task port。",
        techniques=[
            "弱写原语 + 强布局",
            "dangling port → 泄露 → pipe 可控化",
        ],
        notes=["是“弱原语也能利用”的代表。"],
        refs=[("exploit code", "https://bugs.chromium.org/p/project-zero/issues/detail?id=1564#c10")],
    )

    files[ROOT / "events/13-itw-chain-3.md"] = ev(
        title="In-the-wild iOS Exploit Chain 3 (VXD393/D5500)",
        ios="iOS 11.4",
        cves=None,
        primitive="double-free：DestroyDecoder() 未清理指针导致重复释放。",
        strategy="OSData/IOSurface spray 多轮重占位；通过 OOL ports array + IOSurface 读回泄露目标 port 地址；销毁 holding port drop ref 两次得到已知地址 dangling port。",
        flow="zone GC + segmented spray 定位；pipe buffers 重分配得到 fake port；clock_sleep_trap brute force；pid_for_task 读；构造 fake kernel task port。",
        techniques=[
            "IOSurface 读回泄露",
            "segmented spray + pipe",
        ],
        notes=["in-the-wild 复盘。"],
        refs=[("writeup", "https://projectzero.google/2019/08/in-wild-ios-exploit-chain-3.html")],
    )

    files[ROOT / "events/14-spice.md"] = ev(
        title="Spice (LightSpeed)",
        ios="iOS 11.4.1",
        cves="（可能）CVE-2018-4344",
        primitive="lio_listio() race 导致 UAF；通过 OOL ports array + IOSurface spray 获得可控 fake port right。",
        strategy="一线程循环触发 race；另一线程发送 OOL ports array 并喷射 kalloc.16，race 赢时用假数组重占位；接收得到 fake port receive right。",
        flow="notification 泄露地址；mach_port_get_attributes 建读原语；定位对象；转 fake user client 用 iokit_user_client_trap 得到 7 参数任意调用；构造 fake kernel task port。",
        techniques=[
            "kalloc.16 race + spray",
            "notification 泄露",
            "fake user client + trap 任意调用",
        ],
        notes=["survey 注记：PAN 启用时不可用。"],
        refs=[
            ("LightSpeed writeup", "https://www.synacktiv.com/posts/exploit/lightspeed-a-race-for-an-iosmacos-sandbox-escape.html"),
            ("code", "https://github.com/JakeBlair420/Spice"),
        ],
    )

    files[ROOT / "events/15-treadm1ll.md"] = ev(
        title="treadm1ll (LightSpeed variant)",
        ios="iOS 11.4.1",
        cves="（同 LightSpeed）",
        primitive="同 LightSpeed：race 导致 double-free/UAF，最终得到 fake port right。",
        strategy="先制造消息中 dangling OOL 指针，再逐条接收并用 IOSurface spray 重占位为假数组。",
        flow="notification 泄露；pid_for_task 建读原语；转 fake user client + iokit_user_client_trap 任意调用；构造 fake kernel task port。",
        techniques=["逐条接收+重占位提升成功率", "pid_for_task 读", "trap 任意调用"],
        notes=["survey 注记：PAN 启用时不可用。"],
        refs=[("code", "https://github.com/tihmstar/treadm1ll")],
    )

    files[ROOT / "events/16-chaos.md"] = ev(
        title="Chaos",
        ios="iOS 12.1.2",
        cves="CVE-2019-6225",
        primitive="task_swap_mach_voucher() MIG lifetime 语义问题导致 ipc_voucher UAF。",
        strategy="喷射 vouchers 并触发漏洞降低 refcount 释放；释放同页并做 zone GC 让 ith_voucher dangling。",
        flow="OSString/IOSurface 读回泄露 voucher port 地址；大 spray 在硬编码地址附近构造 fake port 并更新 iv_port；thread_get_mach_voucher 得到 fake port right；pid_for_task 建读；转 fake map port remap；构造 fake kernel task port。",
        techniques=["thread_get_mach_voucher 关键转换点", "IOSurface 读回泄露", "remap 使对象可持续更新"],
        notes=["survey 注记：A12 PAC 与 iOS12 port finalize 缓解改变常见结构。"],
        refs=[("360 blog", "https://blogs.360.cn/post/IPC%20Voucher%20UaF%20Remote%20Jailbreak%20Stage%202%20(EN).html")],
    )

    files[ROOT / "events/17-voucher_swap.md"] = ev(
        title="voucher_swap",
        ios="iOS 12.1.2",
        cves="CVE-2019-6225",
        primitive="同 CVE-2019-6225：dangling voucher。",
        strategy="groom ipc_port 与 pipe buffers；触发漏洞/GC 形成 ith_voucher dangling。",
        flow="OOL ports array 重占位并把 ipc_port 指针“推进”到 pipe buffers 形成 fake port；notification 泄露另一个 port 地址计算 fake port 自身地址；pid_for_task 建读；构造 fake kernel task port。",
        techniques=["指针搬运到 pipe buffer", "notification 泄露", "pid_for_task 读"],
        notes=["建议配合原作者 writeup 理解 MIG 语义。"],
        refs=[
            ("writeup", "https://projectzero.google/2019/01/voucherswap-exploiting-mig-reference.html"),
            ("exploit code", "https://bugs.chromium.org/p/project-zero/issues/detail?id=1731#c10"),
        ],
    )

    files[ROOT / "events/18-machswap2.md"] = ev(
        title="machswap2",
        ios="iOS 12.1.2",
        cves="CVE-2019-6225",
        primitive="dangling voucher + OSString/IOSurface，最终得到 pipe buffers 内 fake port right。",
        strategy="OSString 重占位并在 thread_get_mach_voucher 时泄露 voucher port 地址。",
        flow="pipe buffers spray（在泄露地址后约 1MB）；更新 iv_port 指向 pipe buffers；再次 thread_get_mach_voucher 得到 fake port right；pid_for_task 建读；构造 fake kernel task port。",
        techniques=["IOSurface 读回泄露", "距离假设 + pipe spray", "pid_for_task 读"],
        notes=["survey 注记：有 pre-PAN 与 PAN-enabled 两版本；此为 PAN-enabled。"],
        refs=[
            ("code", "https://github.com/PsychoTea/machswap2"),
            ("blog", "https://sparkes.zone/blog/ios/2019/04/30/machswap-ios-12-kernel-exploit.html"),
        ],
    )

    files[ROOT / "events/19-itw-chain-5.md"] = ev(
        title="In-the-wild iOS Exploit Chain 5 (task_swap_mach_voucher)",
        ios="iOS 12.1.2",
        cves="CVE-2019-6225",
        primitive="同 CVE-2019-6225：dangling voucher。",
        strategy="喷射 vouchers 并触发漏洞/GC 形成 ith_voucher dangling。",
        flow="OOL memory spray 泄露 voucher port 地址；再次 spray 更新 iv_port；destroy ports + GC 让 fake voucher 指向 dangling port；pipe buffers 重占位；thread_get_mach_voucher 得到 fake port right；pid_for_task 建读；构造 fake kernel task port。",
        techniques=["OOL memory/ports 作为喷射与回收", "GC + destroy 制造 dangling", "pipe 重占位"],
        notes=["in-the-wild 复盘。"],
        refs=[("writeup", "https://projectzero.google/2019/08/in-wild-ios-exploit-chain-5.html")],
    )

    files[ROOT / "events/20-itw-chain-4.md"] = ev(
        title="In-the-wild iOS Exploit Chain 4 (cfprefsd + ProvInfoIOKit)",
        ios="iOS 12.1.3",
        cves="CVE-2019-7287",
        primitive="ProvInfoIOKitUserClient::ucEncryptSUInfo() 线性堆溢出（未检查 memcpy）。",
        strategy="第一次触发把目标 port 地址拷入可读 OSData；第二次触发把 port 指针插入 OOL ports array；free port + GC 留下 dangling 指针；pipe buffers 重占位并接收 OOL ports 得到 fake port right。",
        flow="fake clock port + clock_sleep_trap brute force；fake task port + pid_for_task 读；构造 fake kernel task port。",
        techniques=["用拷贝溢出做指针搬运到 OSData", "OOL ports 搬运 rights", "clock brute force + pid_for_task"],
        notes=["in-the-wild 复盘。"],
        refs=[
            ("writeup", "https://projectzero.google/2019/08/in-wild-ios-exploit-chain-4.html"),
            ("Apple security content", "https://support.apple.com/lt-lt/HT209520"),
        ],
    )

    files[ROOT / "events/21-attacking-iphonexsmax.md"] = ev(
        title="Attacking iPhone XS Max",
        ios="iOS 12.1.4",
        cves=None,
        primitive="UNIX domain socket bind 的 race/UAF（temporary unlock antipattern）。",
        strategy="spray sockets；触发使 vnode 中保留 dangling socket 指针；GC 后 OSData spray 重占位并构造 refcount=0 的 fake socket。",
        flow="触发 socket_unlock 导致 OSData 被释放并形成 dangling OSData/OOL ports array（survey 标注部分不确定）；再通过 OOL ports array 插入 fake port 指针并接收得到 fake port right；最终转 fake kernel task port（细节不完整）。",
        techniques=["UAF + OSData/IOSurface spray", "OOL ports array rights 搬运"],
        notes=["survey 注记：公开资料仅演讲，存在不确定性；描述为 PAC 版本。"],
        refs=[("slides", "https://i.blackhat.com/USA-19/Thursday/us-19-Wang-Attacking-IPhone-XS-Max.pdf")],
    )

    files[ROOT / "events/22-sockpuppet.md"] = ev(
        title="SockPuppet",
        ios="iOS 12.2 / 12.4",
        cves="CVE-2019-8605",
        primitive="in6_pcbdetach() UAF，可构造安全的任意读、任意 kfree、端口地址泄露原语。",
        strategy="用 OSData/IOSurface 重占位 ip6_pktopts，实现：getsockopt 读、setsockopt free、OOL ports 泄露 port 指针。",
        flow="泄露当前 task；找到 pipe buffers；在 pipe buffer 构造 fake kernel task port；释放另一 pipe buffer 并用 OOL ports array 重占位；写 pipe 插入 fake port 指针并接收得到 fake kernel task port。",
        techniques=["可验证重占位的稳定原语", "getsockopt/setsockopt 触发器", "pipe buffer 作为承载"],
        notes=["survey 注记：结构更像分层而非线性；12.3 修复后 12.4 回归。"],
        refs=[
            ("walkthrough", "https://projectzero.google/2019/12/sockpuppet-walkthrough-of-kernel.html"),
            ("exploit code", "https://bugs.chromium.org/p/project-zero/issues/detail?id=1806#c13"),
        ],
    )

    files[ROOT / "events/23-appleave2driver.md"] = ev(
        title="AppleAVE2Driver exploit",
        ios="iOS 12.4.1（条目注记：<= 13.1.3 也受影响）",
        cves="CVE-2019-8795 + CVE-2019-8794",
        primitive="CVE-2019-8795：内存破坏/受控虚调用或任意 kfree；CVE-2019-8794：未初始化栈数据泄露破 KASLR。",
        strategy="先泄露 KASLR slide；IOSurface OSData 喷射 fake task ports；触发漏洞释放硬编码地址处的 OSData 形成 dangling；通过 OOL ports array 构造 rights 与指针插入。",
        flow="用 pid_for_task 读关键对象指针；再通过释放/重分配升级为 fake kernel task port。",
        techniques=["信息泄露破 KASLR", "OSData + OOL ports 指针/rights 搬运", "pid_for_task 读"],
        notes=["survey 注记：有 non-PAC 与 PAC 两版本；此为 PAC 版本。"],
        refs=[
            ("ZecOps blog", "https://blog.zecops.com/vulnerabilities/releasing-first-public-task-for-pwn0-tfp0-granting-poc-on-ios/"),
            ("ZecOps repo", "https://github.com/ZecOps/public/tree/master/ZecOps_FreeTheSandbox_iOS_PAC_TFP0_POC_BEQ_12_4_2"),
            ("SSD advisory", "https://ssd-disclosure.com/ssd-advisory-via-ios-jailbreak-sandbox-escape-and-kernel-r-w-leading-to-rce/"),
        ],
    )

    files[ROOT / "events/24-oob_timestamp.md"] = ev(
        title="oob_timestamp",
        ios="iOS 13.3",
        cves="CVE-2020-3837",
        primitive="IOAccelCommandQueue2::processSegmentKernelCommand() 线性堆 OOB 写（最多 8 字节 timestamp）。",
        strategy="通过大规模内核 map 布局与 IOSurface OSData spray，溢出破坏 ipc_kmsg.ikm_size 变大；释放后用 OSData 重占位 OOL ports array 并插入 hardcoded 地址处 fake port 指针。",
        flow="接收 OOL ports 得到 fake port receive right；用 pid_for_task 建读原语；定位对象并构造 fake kernel task port。",
        techniques=["扩大 ipc_kmsg size 制造重叠窗口", "共享内存/大块落点辅助稳定重叠", "pid_for_task 读"],
        notes=["survey 注记：iOS 13 的 zone_require 会影响 fake port；该条目提到一次实现疏漏绕过。"],
        refs=[("exploit code", "https://bugs.chromium.org/p/project-zero/issues/detail?id=1986#c5")],
    )

    files[ROOT / "events/25-tachy0n.md"] = ev(
        title="tachy0n (unc0ver 5.0.0)",
        ios="iOS 13.5",
        cves="（LightSpeed regression）",
        primitive="LightSpeed 漏洞在 iOS 13 回归：race 触发 kalloc.16 上的 double-free/UAF。",
        strategy="survey 给出初步结论：释放的 kalloc.16 槽位可能被 IOSurface OSData spray 重占位（更完整分析需等待代码公开）。",
        flow="survey 标注 Analysis pending：整体仍沿用 LightSpeed 系列的 race + spray 获得可控对象/原语，再进一步拿到内核能力。",
        techniques=["回归型漏洞（regression）", "kalloc.16 race + spray"],
        notes=[
            "unc0ver 版本为混淆二进制，survey 明确标注分析未完成。",
            "survey 认为这是 regression 而非变种：原 LightSpeed POC 在 iOS 13 可触发。",
        ],
        refs=[
            ("LightSpeed writeup", "https://www.synacktiv.com/posts/exploit/lightspeed-a-race-for-an-iosmacos-sandbox-escape.html"),
            ("unc0ver release", "https://github.com/pwn20wndstuff/Undecimus/releases/tag/v5.0.0"),
        ],
    )

    # Write
    for path, content in files.items():
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(content, encoding="utf-8")

    print(f"Wrote {len(files)} markdown files")


if __name__ == "__main__":
    main()
