# PAC（Pointer Authentication Codes，iOS 12，对应 A12）

## 机制是什么
PAC 是 ARMv8.3-A 的指针认证机制，将指针值的签名放入高位，用于检测指针篡改。Apple 在 A12 引入并强化实现，使其在内核里承担类似 CFI 的效果：把“内核读写”与“稳定的内核代码执行”隔开。

## 对利用链的影响（survey 的归纳）
- PAC 会显著限制依赖控制流劫持的技术（例如 vtable/fptr 篡改直接变成任意执行）。
- survey 指出：过去有些链路会先拿到执行再转读写；在 A12 上通常不再是默认可行路线，除非先绕过 PAC。
- IOKit 中大量 PAC 保护指针的使用，也让“把 bug 变成好用原语”变得更困难。

## 参考内容摘要

**核心机制**：PAC（Pointer Authentication Codes，iOS 12 A12+）基于 ARMv8.3-A，在指针的高位嵌入加密签名（使用密钥、上下文和指针值）。访问前必须验证签名；任何篡改指针值都会导致签名失效，CPU 触发异常。Apple 在内核中广泛使用 PAC 保护虚表、函数指针、返回地址。

**对现代利用的影响**：PAC 大幅限制了"获得内核读写权限后任意控制流劫持"的路线。早期链（如 extra_recipe、v0rtex）可能先拿到执行权（vtable 篡改），再用执行权实现任意读写；A12+ PAC 使这路困难化。IOKit 驱动中大量指针（method dispatch、callback 函数指针）都被 PAC 保护，"污染驱动对象劫持虚调用"的难度大幅上升。现代 exploit 倾向于：①优先追求可靠的读写原语；②使用 gadget（不依赖修改指针但能实现目标功能）；③在特定上下文中寻找签名验证漏洞。

**绕过现状**：survey 截至 2020-05 未记录完整 PAC 绕过，但多条 A12+ 链（如 hsp4、chaos、treadm1ll）仍成功利用，说明存在 PAC 局限性（例如某些驱动指针未必被保护、或存在签名检查漏洞）。

**缓解评估**：PAC 是现代 iOS 缓解中最强的控制流保护，显著提升了从任意写到任意执行的难度，但不能防御已有任意读写原语的情况。

## 参考
- Survey：iOS kernel exploit mitigations / PAC
