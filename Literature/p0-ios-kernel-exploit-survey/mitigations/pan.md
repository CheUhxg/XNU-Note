# PAN（iOS 10，对应 A10）

## 机制是什么
PAN（Privileged Access Never）阻止内核直接访问同时对用户态可访问的虚拟地址，避免内核随意解引用攻击者提供的 userspace 指针。

## 对利用链的影响（survey 的归纳）
- 很多“把假结构体放在用户态内存让内核用”的套路在 PAN 下不可直接用。
- 现代 exploit 常见的应对是：
  - 把可控数据喷进内核（IOSurface/pipe/OOL 等），再通过泄露/定位得到内核地址
  - 或利用共享内存映射等机制建立可控的 kernel 可访问区域
- survey 也提到：曾有公开绕过，但大多数利用选择“work around”而非正面绕过。

## 参考内容摘要

**核心机制**：PAN（Privileged Access Never，iOS 10 A10+）是 ARMv8.1 特性，CPU 在 EL1（kernel 特权）执行时禁止直接访问 EL0（用户态）虚拟地址空间。任何内核代码尝试 load/store 到用户地址都会触发异常。绕过需要显式禁用（例如 `__asm__("msr pan, #0")` 在特定窗口内）。

**对现代利用的影响**：PAN 直接禁止了"在用户态构造 fake 结构体让内核解引用"的经典套路。例如早期链（yalu102 的 clock port fake）直接依赖内核读取用户态的伪造 port 结构，在 PAN 下失效。现代 exploit 应对策略：①把可控数据喷进内核堆（IOSurface、pipe buffers、OOL ports 数组、IPC kmsg）；②通过泄露 + KASLR 推导获得内核地址；③实现内核读原语后再用内核地址操作数据。

**绕过现状**：survey 统计的所有 iOS 10+ 链（bpf-filter, multi_path, empty_list, async_wake, voucher_swap 等）都包含"数据在内核侧"的设计，大多数避免了直接 PAN 绕过。少数链试图绕过（如通过 SPRR/APRR 的实现漏洞），但 Apple 快速修补。主流思路是"work around"而非对抗。

**缓解评估**：PAN 有效阻止了简单的 fake 结构体套路，提升了 exploit 复杂度（必须先获得可控内核内存），但不能单独防御有内核读写原语的攻击。

## 参考
- Survey：iOS kernel exploit mitigations / PAN
